\section{Программные средства модуля управления}

Программные средства модуля управления созданы на основе проекта Facebook OpenBMC для МУС на основе микросхемы Aspeed AST2400. Данный проект содержит загрузчик U-BOOT, ядро ОС Linux версии 4.1.51 и СПО для модулей управления системой.

Проект OpenBMC в свою очередь основан на проекте Yocto, позволяющем собирать прошивки с загрузчиком и ОС для большого набора архитектур, таких как ARM, MIPS, PowerPC, x86/x86-64 и др. Также проект Yocto предоставляет систему планирования задач и сборки Bitbake.

Итогом создания программных средств МУС является бинарный файл, содержащий образ загрузчика, ядра ОС и файловой системы.

\subsection{Проект Yocto}

Проект Yocto и все построенные на его основе проекты используют определенный способ описания сборки с использованием метаданных.

\subsubsection{Определения}

\begin{itemize}
	\item Метаданные – файлы, которые Bitbake парсит при сборке образа. Метаданные включают в себя рецепты, классы и конфигурационные файлы;
	\item Рецепты (.bb файлы) – набор инструкций для сборки пакетов. Они описывают, где находится исходный код и какие патчи применять. Также описывают зависимости для библиотек, содержат параметры конфигурации и компиляции. recipies-name;
	\item Слой – набор рецептов по какому-либо признаку, например слой ядра, слой пакета поддержки платы и слой приложений. Обозначается meta-name;
	\item Файлы классов (.bbclass) – файлы, обеспечивающие логическую инкапсуляцию и наследование рецептов;
	\item Файлы конфигурации (.conf) – файлы, в которых заданы глобальные переменные.
\end{itemize}

Для сборки под другую целевую архитектуру в Yocto Project используется кросс-компилятор Cross-Development Toolchain (gcc-cross, binutils-cross и др.), 
а также QuickEMUlator (QEMU) для моделирования целевого оборудования.

\subsubsection{Создание рецепта}

Для создания рецепта проделаны следующие действия:
\begin{itemize}
	\item Создание рецепта в подходящем слое и наборе рецептов
	\item Необходимо задать определенное имя: recipiename\_verion.bb. 
	\item Рецепт указывает, как получить исходные файлы через SRC\_URI переменную.
	\item Задача do\_fetch ищет файлы и запускает do\_patch. Файл желательно называть так же, как и рецепт, иначе надо указывать путь до файла.
	\item Задача do\_patch ищет файлы .patch или .diff и применяет исправления, если таковые есть.
	\item Задача do\_unpack распаковывает исходный код с указанием места распаковки.
	\item Любые зависимости времени сборки надо указать в переменной DEPENDS
	\item Есть несколько способов конфигурации в зависимости от построения программного обеспечения.

1)	Autotools: конфигурируется с помощью configure.ac файла. Рецепт не должен содержать do\_configure задачу и должен наследовать autotools класс.

2)	CMake: информация о конфигурации содержится в файле CMakeLists.txt. Рецепт должен наследовать cmake класс и не должен содержать do\_configure.

3)	Другие: использование do\_configure в рецепте.
	\item Задача do\_compile выполняется после настройки. На этом этапе могут появиться ошибки, которые требуется исправить. В результате будут получены исполняемые файлы.
	\item Задача do\_install копирует исполняемые файлы с их иерархией в местоположения, которые будут отражать их расположение на целевом устройстве. Создается структура как на целевом устройстве. В случае конфигурации Autotools или CMake установка производится ими, do\_install не требуется.
	\item Задача do\_package разбивает файлы, полученные в рецепте в логические компоненты., такие как отладочные символы, документацию. Задача гарантирует, что файлы разделены и установлены правильно.
\end{itemize}

Были созданы и отредактированы рецепты, работающие со скриптом загрузки и GPIO.

\subsubsection{Программа сборки Bitbake}

Сборка программой Bitbake производится следующим образом:
\begin{itemize}
	\item Производится парсинг и конфигурация метаданных, затем парсинг рецептов. 
	\item Для каждого рецепта строится список целей для рецепта (например, поиск и скачивание файлов, распаковка, компиляция, установка). 
	\item Определяются зависимости между рецептами. Они задаются командами bitbake в самом рецепте.
	\item Строится список задач. Bitbake определяет какие задачи и в каком порядке он должен выполнять. Bitbake разветвляет потоки для ускорения. Можно задать переменную BB\_NUMBER\_THREADS с числом потоков для ускорения сборки.
	\item Идет выполнение задач. Задачи могут быть задачами оболочки или Python. Для задачи оболочки Bitbake записывает сценарий оболочки, а затем выполняет его. Для Python Bitbake выполняет задачу внутренне, затем записывает информацию на управляющий терминал.
	\item Результаты кэшируются, и при пересборке не требуется перевыполнять не измененные задачи.
\end{itemize}

Сборка программных средств производилась программой Bitbake.

\subsection{Исходный код прошивки}

В исходном проекте OpenBMC предусмотрены дополнительные слои и рецепты в дополнение к проекту Yocto:

\begin{itemize}
	\item common - исходный код пактов и рецептов, используемых в МУС;
	\item meta-aspeed - исходный код драйверов, файлов конфигурации загрузчика и ОС и инструментов для SoC AST2400;
	\item meta-facebook - исходный код драверов и файлов конфигурации прошивки для конкретного модуля. Данный слой был адаптирован для разработанной МУС.
\end{itemize}

В слое meta-facebook/meta-yosemite добавлены и доработаны рецепты, позволяющие реализовать следующий функционал:
\begin{itemize}
	\item rikgpio - определение необходимых пинов GPIO, их направление (in/out) и значение;
	\item rikcgi - скритпы, позволяющие включать/выключать и перезагружать системный модуль;
	\item initsc - скрипт, выполняемый при запуске и задающий стартовые значения GPIO, запускающий другие скрипты конфигурации;
	\item dscan - задание адресов, по которым будет проведено сканирование устройств I2C;
	\item riknet - скрипт, задающий настройки сети, сохраняющий текущие настройки на флеш-памяти.
\end{itemize}

В рецепте rikgpio отредактирован файл rikgpio.c, в нем были прописаны используемые пины GPIO, их направление (вход-выход) и название. Далее в файле представлены следующие функции, конфигурирующие GPIO: gpio\_num (получение номера GPIO в программных средствах по номеру его пина), gpio\_export (создание GPIO в ПС), gpio\_set\_direction (устанавливает направление GPIO) и gpio\_set\_value (устанавливает выходное значение).

В рецепте initsc прописаны начальные значения пинов GPIO, а также запущен скрипт netconf-script.sh из рецепта riknet. 

В рецепте rikcgi в трех скриптах прописаны алгоритмы установки значений в GPIO для эмуляции кнопки включения и перезагрузки. Скрипт server\_pwrbut\_s.sh устанавливает GPIO №109, подключенный к кнопке включения питания, в направление "выход", затем устанавливает его в "0", делает паузу 1 сек., и устанавливает "1". После чего задается направление "вход". Скрипт более долгого нажатия server\_pwrbut\_h.sh выполняет то же самое, но делает паузу 5 сек., что приводит к гарантированному выключению. Скрипт server\_reset.sh устанавливает GPIO сигнала сброса в "0", затем возвращает "1".

В рецепте riknet файл netconf-script.sh считывает заданные ранее адреса IP и MAC с флешки, если их нет, создает на флешке файл с ними и прописывает стандартные. Также есть файл net.conf.example -- пример файла конфигурации, в котором прописано начальное значение net.conf.

В рецепте dscan в файле dscan.conf указаны I2C адреса, устройства и шины, по которым следует производить поиск I2C устройств.

Также выкачан исходный код ОС Linux и загрузчик U-BOOT для OpenBMC. В загрузчике произведена замена последовательного порта со стандартного на примененный в МУС. В ОС включены необходимые модули и поправлен драйвер MAC Ethernet. 

Для настройки загрузчика и ОС их исходный код требуется загрузить. В папке сборки прошивки \ref{building-firmware} необходимо выполнить:
\begin{lstlisting}
$ devtool modify u-boot
$ devtool modify linux-aspeed
\end{lstlisting}

Последовательный порт ОС задается в файле ./meta-facebook/meta-yosemite/recipes-core/sysvinit/sysvinit-inittab\_\%.bbappend

\subsection{Сборка программных средств}

Сборка программных средств МУС производится утилитой Bitbake. Для сборки необходимо открыть рабочую директорию проекта и выполнить следующие действия:
\label{building-firmware}
\begin{lstlisting}
$ source yo
\end{lstlisting}

Рабочей директрией станет ./build.

В машине с файловой системой nfs необходимо задать место для сборки с другой файловой системой. Для этого в файле ./conf/local.conf необходимо дописать строку TMPDIR = "/ address /tmp/Yocto".

Далее задание последовательного порта модуля (№2)
\begin{lstlisting}
$ devtool modify u-boot
$ cd workspace/sources/u-boot
$ grep 'ttyS0' -P -R -I -l * | xargs sed -i 's/ttyS0/ttyS2/g'
$ cd ../../../
\end{lstlisting}

Парсинг всех рецептов и сборка запускаются командой
\begin{lstlisting}
$ bitbake yosemite-image
\end{lstlisting}

\subsection{Работа с программными средствами}

Системным модулем, системой или управляемым модулем называется модуль, в который установлен рассматриваемый МУС. МУС предназначен для проведения действий с системным модулем. При этом системный модуль может быть выключен, достаточно подать на него питание.

Разработанный модуль предоставляет следующий функционал:
\begin{itemize}
	\item Удаленная работа с МУС по сети;
	\item Включение, выключение и перезагрузка системного модуля;
	\item Подключение к последовательному порту системы и работа с консолью системы;
	\item Работа с I2C устройствами системного модуля.
\end{itemize}

Подключение к МУС-А осуществляется по последовательному порту МУС( выведен на штыревой соединитель системного модуля), или по локальной сети (один или два интерфейса LAN 10/100 выведены на соединители задней панели системного модуля).

На модуле устанавливаются определенные IP и MAC адреса двух интерфейсов Ethernet. Они могут быть изменены редактированием файла net.conf на флеш-памяти МУС в программных средствах МУС после перезагрузкм МУС.

\addimghere{mus-example-ip.png}{0.7}{Файл конфигурации IP и MAC net.conf}{mus-example-ip}

Пароль учетной записи МУС также сохраняется на флеш-памяти МУС и может быть изменен утилитой passwd-util.

Подключение МУС к последовательному порту системы через порт ttyS1 МУС осуществляется утилитой microcom:
\begin{lstlisting}
microcom -t 100000 -s 115200 /dev/ttyS1
\end{lstlisting}

Для управления включением/выключением и перезагрузкой были написаны следующие скрипты:

\begin{itemize}
	\item server\_reset.sh - перезагрузка системы;
	\item server\_pwrbut\_s.sh короткое нажатие кнопки включения, 1сек.;
	\item server\_pwrbut\_h.sh длинное нажатие кнопки включения, 5сек.
\end{itemize}

В состав программных средств включены модули драйверов I2C устройств. Пример подключения и обращения к памяти EEPROM приведен ниже:
\begin{lstlisting}
echo 24c128 0x57 > /sys/bus/i2c/devices/i2c-3/new_device
hexdump -С /sys/bus/i2c/devices/i2c-3/3-0057/eeprom
\end{lstlisting}
Здесь 3 – шина i2c, 24с128 – устройство i2c, 0x57 – верхние 7 бит адреса в шине. 

Реализована возможность подключаться к EEPROM памяти (в примере, устройство 24c128) и термодатчикам (устройство lm96163) согласно их адресам и шинам. Необходимо учесть, что нумерация шин в программных средствах МУС-А изменена относительно шин МУС в электрической схеме системного модуля:
Шине 0 МУС на схеме системного модуля соответствует шина 5 в ПС МУС-А.
Представлен полный список соответствия шин (номер на схеме -> номер в программных средствах):
\begin{itemize}
	\item 0->5;
	\item 1->6;
	\item 2->7;
	\item 3->2;
	\item 4->3.
\end{itemize}

На рисунке \ref{mus-example} приведен пример работы в консоли разработанного МУС:
\addimghere{mus-example.png}{0.95}{Пример работы в консоли МУС-А}{mus-example}

Показаны вход в учетную запись МУС, смена пароля, включение системы, перезагрузка системы, подключение последовательного порта системы, вывод информации системы из-под ее учетной записи, подключение памяти EEPROM и чтение данных.

С удаленной машины реализовано по локальной сети через один из двух интерфейсов LAN 10/100 по ssh. Подключение к МУС осуществляется командой:
\newline ssh <имя хоста или IP-адрес МУС>

С удалённой машины также реализована возможность подключиться сразу к последовательному порту системного модуля (к порту 2022):
ssh -p 2022 <имя хоста или IP-адрес МУС>

Порт прямого входа на com-порт управляемой машины (по умолчанию: 2022) меняется в файле /mnt/data/etc/ssh/sshd\_config (в двух местах: в директиве Port и в строке Match).
vi /mnt/data/etc/ssh/sshd\_config

Пример работы с МУС с удаленной машины представлен на рисунке \ref{mus-example-sys}:
\addimghere{mus-example-sys.png}{0.95}{Пример подключения к МУС-А по сети и подключения к последовательному порту системы по сети}{mus-example-sys}

\clearpage
